# 虚拟机类执行引擎
######

# 目录索引
  * <a href="#A">运行时栈帧结构</a>
    * <a href="#a1">局部变量表</a>
    * <a href="#a2">操作数栈</a>
    * <a href="#a3">动态链接</a>
    * <a href="#a4">方法返回地址</a>
  * <a href="#B">方法调用</a>
     * <a href="#b1">解析</a>
     * <a href="#b2">分派</a>
     * <a href="#b3">动态类型支持</a>
  * <a href="#C">基于栈的字节码解析执行引擎</a>
     * <a href="#c1">解释执行</a>
     * <a href="#c2">基于栈的指令集与基于寄存器的指令集</a>
     * <a href="#c3">基于栈的解释器执行过程</a>

## <a name="A">运行时栈帧结构</a>
* 栈帧，虚拟机进行方法调用和方法执行的数据结构，虚拟机运行时时数据区中的虚拟机栈的栈元素。
* 栈帧 存储了方法的局部变量表，操作数栈，动态链接，方法返回地址等信息。
* 每一个方法从调用开始到执行结束的过程，对应一个栈帧在虚拟机栈里入栈到出栈的过程。
* 在编译时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定，并写入方法表的 Code 属性中。
* 一个线程中方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎而言，只有位于栈顶的栈帧才是有效的，称为当前栈帧，对应的方法称为当前方法。


![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)
### <a name="a1">局部变量表</a>
* 局部变量表 是一组存储变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
* 局部变量表的容量以变量槽(solt)为最小单位，虚拟机没有规定一个 solt 应占用内存大小，只是提到每个 solt 都应该能存放一个 boolean byte char short int float reference returnAddress 类型的数据。这8种数据类型可以使用32位或者更小的物理内存来存储。在64位的虚拟机中也可以使用64位的物理内存实现一个 solt，只是虚拟机需要使用对齐和补白的手段让 solt 在外观上看起来与32位虚拟机中一致。
* reference 类型，虚拟机没有说明其长度及结构，但是一般虚拟机至少应该通过这个引用做到2点
    > 1. 从该引用可以直接或间接找到对象在Java堆中数据存放的起始地址索引。    
    > 2. 从该引用可以直接或间接找到对象所属数据类型在方法区中的存储的类型信息。   
* Java虚拟机明确规定64位的数据类型只有long和double。
* 对应实例方法，局部变量表第0位索引的 slot 存放方法所属对象的实例引用(this)，其余参数按照参数表顺序排列占用从1开始的局部变量solt，参数表分配完后，再跟进方法体内部定义的变量顺序和作用域分配其余的solt。
* 局部变量表中 solt 是可以复用的。

### <a name="a2">操作数栈</a>
### <a name="a3">动态链接</a>
### <a name="a4">方法返回地址</a>

## <a name="B">方法调用</a>
### <a name="b1">解析</a>
* 所有方法调用中的目标方法在 Class 文件里面都是一个常量池中符号引用，在类加载的解析阶段，会将部分符号引用转换为直接引用，这种解析成立的前提条件是：方法在程序运行前就有一个可确定的调用版本，并且这个调用版本在运行期间不可变。换句话说调用目标在程序代码写好，编译器进行编译时就必须确定下来。这类方法的调用称为-解析。
* Java语言中符合”编译期可知，运行期不变“要求的方法有：静态方法、私有方法。
* Java虚拟机提供5条方法调用指令：
    > 1. invokestatic 调用静态方法。      
    > 2. invokespecial 调用实例构造器<init>方法、私有方法、父类方法。      
    > 3. invokevirtual 调用所有的虚有方法。     
    > 4. invokeinterface 调用接口方法，会在运行时再确定实现该接口的对象。     
    > 5. invokedynamic 现在运行时动态解析出调用点限定符的方法，然后再执行该方法，在此之前的4条指令，分派逻辑是固化在Java虚拟机内部的，而 invokedynamic 指令的分配逻辑用户所设定的引导方法决定。    

* 只要能被 invokestatic、 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有 静态方法、私有方法、实例构造器、父类方法 4 种。它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，其他方法称为虚方法(final 方法除外)。
* 解析调用是一个静态过程，而分派调用则可能是静态的也可能是动态的，根据分派依据的宗数量可以分为单分派和多分派。两种分派方式的两两组合有：静态单分派、静态多分派、动态单分派、动态多分派。

### <a name="b2">分派</a>
* 虚拟机在重载时通过参数的静态类型而不是实际类型作为判断依据。静态类型在编译器可知，所以编译器会根据参数的静态类型决定使用哪个版本的重载。
* 静态分派的典型应用是方法重载。
* 字面量没有显示的静态类型，它的静态类型只能通过语音上的规则去理解和推断。
* 动态分派的典型应用是方法重写。
* invokevirtual 指令运行时解析过程
    > 1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作 C。     
    > 2. 如果在类型 C 中，找到与常量中描述符和简单名称都一样的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过抛出 java.lang.IllegalAccessError。     
    > 3. 否则，按照继承关系从下往上一次对 C 的父类进行第二步的搜索和验证过程。    
    > 4. 如果始终没有找到合适的方法，则抛出 java.lang.IllegalAccessError。     
    
### <a name="b3">动态类型支持</a>

## <a name="C">基于栈的字节码解析执行引擎</a>
> 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，  
> 这个过程就是虚拟机的类加载机制。
### <a name="c1">解释执行</a>
### <a name="c2">基于栈的指令集与基于寄存器的指令集</a>
### <a name="c3">基于栈的解释器执行过程</a>
