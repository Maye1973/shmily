# 虚拟机类加载机制
######

# 目录索引
  * <a href="#A">类加载的时机</a>
    * <a href="#a1">加载时机</a>
  * <a href="#B">类加载的过程</a>
     * <a href="#b1">加载</a>
     * <a href="#b2">验证</a>
     * <a href="#b3">解析</a>
     * <a href="#b4">初始化</a>
  * <a href="#C">类加载器</a>
     * <a href="#c1">类与类加载器</a>
     * <a href="#c2">双亲委派模型</a>
     * <a href="#c3">破坏双亲委派模型</a>


## <a name="A">类加载的时机</a>
> 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，  
> 这个过程就是虚拟机的类加载机制。
### <a name="a1">类加载的时机</a>
* 类从被加载到虚拟机内存中到卸载出内存，整个生命周期包括7个阶段：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载。其中 准备、解析、初始化统称为连接。
    > 加载、验证、准备、初始化、卸载 这5个阶段的顺序是确定的(相互交叉地混合进行)。  
    > 解析阶段可以在初始化阶段之后再开始，为了支持Java的动态绑定(运行时绑定)。
* 虚拟机规范没有规定什么时候进行加载，但是严格规定有且只有5种情况必须立即对类进行初始化
    1. 遇到 new getstatic putstatic invokestatic 字节码指令时，如果类没有初始化，则先进行类的初始化。
    2. 使用java.lang.reflect 包的方法对类进行反射调用时，如果类没有初始化，则先进行类的初始化。
    3. 当初始化一个类的时候，如果发现其父类没有进行初始化，则先触发其父类的初始化。
    4. 当虚拟机启动时，需要指定一个要执行的主类，虚拟机会初始化这个主类。
    5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后解析结果为 REF_getStatic REF_putStatic REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化，则先触发该类的初始化。  
* 被动引用不会触发类的初始化
    > 1. 通过子类引用父类的静态字段，只会初始化父类，不会导致子类初始化，但是子类会被加载。。(直接定义该静态字段的类才会被初始化)   
    > 2. 通过数组定义引用类，不会导致该类初始化。(但是会由 newarray 指令触发一个类名为”[L类名“的初始化)
    > 3. 常量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
* 接口的初始化和类的初始化过程唯一的区别在于：接口在初始化时，并不要求其父接口全部都初始化完成，只有真正使用到父接口的时候(引用父接口中定义的常量)才会初始化父接口。
## <a name="B">类加载的过程</a>

### <a name="b1">加载</a>
* 加载阶段需要完成3件事
    1. 通过一个类的全限定名来获取一个定义此类的二进制字节流。
    2. 将这个字节流所代表的静态存储结构转化为“方法区”的运行时数据结构。
    3. 在内存中生成一个代表这个类的 java.lang.Class 对象(HotSpot 在方法区创建)，作为方法区这个类的各种数据的访问入口。
* 数组本身不通过类加载器创建，它有 Java 虚拟机直接创建。
    * 数组的创建过程：
        > 1. 如果数组的组件类型(指数组去掉一个维度的类型)是引用类型，采用类加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名空间上被标识。
        > 2. 如果数组的组件类型不是引用类型(如int[])，Java 虚拟机将会把数组标记为与引导类加载器关联。
        > 3. 数组类的可见性与它的组件类型的可见性是一致的，如果组件类型不是引用类型，则数组类的可见性默认为 public 。
* 加载过程和连接阶段的部分内容(如部分字节码文件格式的验证)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

### <a name="b2">验证</a>
* 目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。
* 主要完成4个方面的验证： 文件格式验证、 元数据验证、 字节码验证、 符号引用验证。

    1. 文件格式验证：确保输入的字节流能正确地解析并存储于方法区内，格式上符合描述一个 Java 类型信息的要求。
        > 1. 是否以魔数 0XCAFEBABE 开头。   
        > 2. 主次版本号是否在当前虚拟机处理范围内。   
        > 3. 常量池的常量中是否有不被支持的常量类型(检查常量 tag 标志)。   
        > 4. 指向常量的各种索引值是否有指向不存在的常量或者不符合类型的常量。   
        > 5. CONSTANT_Utf8_info 类型的常量中是否有不符合 UTF8 编码的数据。    
        > 6. Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。   
        > ...... 

    2. 元数据验证：对字节码描述的信息进行“语义”分析，以保证其描述信息符合 Java 语言规范的要求。
        > 1. 是否有父类(除 java.lang.Object 外的类都应该有父类)。
        > 2. 类的父类是否继承了不允许继承的类(被 final修饰的类)。
        > 3. 如果类不是抽象的，是否实现了父类或接口中要求实现的所有方法。
        > 4. 指向常量的各种索引值是否有指向不存在的常量或者不符合类型的常量。
        > ......

    3. 字节码验证：通过数据流和控制流分析，确定程序"语义"是合法的、符合逻辑的。对方法体进行校验，保证被校验类的方法在运行期间不会做出危害虚拟机的安全事件。
        > JDK 1.6 后的 Javac 和 Java 虚拟机进行了一项优化，给方法体的 Code 属性的属性表中新增一项 “StackMapTable” 的属性，
        > 该属性描述方法体中所有基本快开始时本地变量表和操作栈应有的状态。在字节码验证期间，就不用根据程序推导这些状态的合法性，
        > 只需要检查 “StackMapTable” 属性中的记录是否合法即可。 
        > 使用 -XX:-UseSplitVerifier 选项关闭该属性，或者使用 -XX:+FailOverToOldVerifier 要求在类型校验失败后回退到旧的类型推导方式进行校验。
        > 在 JDK 1.7 之后 对应主版本号大于 50 的 Class 文件，使用类型检查来完成数据流分析是唯一的选择，不允许再回退到类型推导的校验方式。

    4. 符号引用验证：在把符合引用转换为直接引用的时候发生，这个阶段在解析阶段中发生。目的是确保解析动作可以正常执行。
* 对虚拟机来说，验证非常重要但不是一定必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，在实施时可以使用 -Xverify:none 参数来关闭大部分的类的验证措施，以缩短虚拟机类加载的时间。 

### <a name="b3">准备</a>
* 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，类变量所使用的内存在方法区分配。
    > 初始值 “通常” 是数据类型的零值，假设一个类变量如下
    > ```java
    > public static int value = 123;
    > ``` 
    > 那么类变量 value 在准备阶段过后初始值是 0 而不是 123。而把 value 赋值为 123 的指令 putstatic 是程序在编译后存放在类构造器 <clinit>() 方法中。
    > 所以把类变量 value 赋值为 123 是在类的初始化阶段。
    > 如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段类变量 value 就会被初始化为 ConstantValue 属性所指定的值。
    > 假设上面的类变量定义为
    > ```java
    > public static final int value = 123;
    > ``` 
    > 编译时 javac 会把 value 生成对应的 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 设置为 123。

### <a name="b3">解析</a>
* 虚拟机将常量池内的符号引用替换为直接引用的过程。
    > 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时可以无歧义的定位到目标既可。
    >   符号引用与虚拟机实现的内存布局无关，引用的目标并不一定加载到内存中。
    >   各虚拟机实现的内存布局可能各不一样，但是它们能接受的符号引用必须都是一致的。

    > 直接引用：直接引用可以是直接指向目标的指针、相当偏移量、一个可以间接定位到目标的句柄。
    >   直接引用和实现虚拟机的布局相关，同一个符号引用在不同的虚拟机上翻译出来的直接引用一笔不一样。
    >   如果有了直接引用，那引用目标必定已在内存中。
* 虚拟机规范没有规定解析阶段发生的具体时间，只要求在执行以下16个操作符号引用指令之前，先对符号引用进行解析.
    > anewarry checkcast getfield getstatic instanceof invokedynamic invokeinterface invokespecial invokestatic invokevirtual ldc ldc_w multianewarry new putfield putstatic

    > 对同一个符号引用进行多次解析很常见，除 invokedynamic 指令之外，虚拟机可以对第一次解析的结果进行缓存。
    > invokedynamic 指令对应的引用称为 动态调用点限定符。
* 解析主要针对 类或接口 字段 类方法 接口方法 方法类型 方法句柄 调用点限定符 7类符号引用进行。
    > 类或接口 - CONSTANT_Class_info   
    > 字段 - CONSTANT_Fieldref_info   
    > 类方法 - CONSTANT_Methodref_info   
    > 接口方法 - CONSTANT_InterfaceMethodref_info   
    > 方法类型 - CONSTANT_MethodType_info   
    > 方法句柄 - CONSTANT_MethodHandle_info   
    > 调用点限定符 - CONSTANT_InvokeDynamic_info   

    > 类或接口的解析：假设当前所处的类为 D，需要把符号引用 N 解析成类或接口 C，类或接口解析过程如下
        > 1. C 不是一个数组，虚拟机把 N 的全限定名传递给 D 的类加载器加载这个类或接口 C。
        >    在加载过程由于元数据交易、字节码验证的需要，又可能触发其他相关类的加载过程。
        > 2. C 是数组，并且数组元素类型为对象(N 的描述符类似 [Ljava/lang/Integer])，将按照步骤1加载数组元素类型。   
        >   如果 N 的描述符如前面假设的形式，需要加载元素类型就是 java.lang.Integer，接着有虚拟机生成一个代表此数组维度和元素的数组对象。
        > 3. 完成以上步骤，C 在虚拟机中已经存为一个有效的类或接口，但还需要进行符号引用验证，   
        >   确认 D 是否具备访问 C 的权限，如果没有，将抛出 java.lang.IllegalAccessError。

    > 字段的解析：需要先完成对类或接口的解析，假设对类或接口的解析后类或接口用 C 表示，则字段解析过程如下
        > 1. C 本身包含了简单名称和字段描述符都与目标相匹配，则返回字段的直接引用，查找结束。
        > 2. 否则 如果 C 实现类接口，将按照继承关系从下往上递归查找 各个接口及父接口，
        >   如果接口包含简单名称和字段描述符都与目标相匹配，则返回字段的直接引用，查找结束。      
        > 3. 否则 如果 C 不是 java.lang.Object， 将按照继承关系从下往上递归查找其父类，       
        >   如果父类包含简单名称和字段描述符都与目标相匹配，则返回字段的直接引用，查找结束。    
        > 4. 否则查找失败，抛出异常 java.lang.NoSuchFieldError。

    > 类方法的解析：需要先完成对类或接口的解析，假设对类或接口的解析后类或接口用 C 表示，则类方法解析过程如下
        > 1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现     
        >   class_index 中索引的 C 是一个接口，则抛出异常 java.lang.IncompatibleClassChangeError。
        > 2. 通过了第1步，在类 C 中查找是否有简单名称和描述符都和目标相匹配的方法，有则返回方法的直接引用，查找结束。    
        > 3. 否则 在类 C 的父类中递归查找是否有简单名称和描述符都和目标相匹配的方法，有则返回方法的直接引用，查找结束。
        > 4. 否则在类 C 的实现的接口列表及父接口递归查找是否有简单名称和描述符都和目标相匹配的方法，有则说明类 C 是一个抽象类，查找结束，抛出 java.lang.AbstractMethodError。  
        > 5. 否则查找失败，抛出异常 java.lang.NoSuchMethodError。   
        > 6. 校验是否有访问方法的的权限，如果没有，将抛出 java.lang.IllegalAccessError。

    > 接口方法的解析：需要先完成对类或接口的解析，假设对类或接口的解析后类或接口用 C 表示，则类方法解析过程如下
        > 1. 如果在接口方法表中发现 class_index 中索引的 C 是一个类，则抛出异常 java.lang.IncompatibleClassChangeError。
        > 2. 通过了第1步，在接口 C 中查找是否有简单名称和描述符都和目标相匹配的方法，有则返回方法的直接引用，查找结束。    
        > 3. 否则 在接口 C 的父接口中递归查找是否有简单名称和描述符都和目标相匹配的方法，有则返回方法的直接引用，查找结束。 
        > 5. 否则查找失败，抛出异常 java.lang.NoSuchMethodError。   

### <a name="b4">初始化</a>
* 在准备阶段，类变量已经赋过一次系统要求的"初始值"，而在初始阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。初始化阶段是执行类构造器<clinit>()方法的过程。
    1. <clinit>() 由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合并产生，顺序为语句在源文件中出现的顺序决定。
    > 静态语句块只能访问定义在静态语句块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。

    2. <clinit>()和类的构造方法(或者说实例构造器init()方法)不同，它不需要显示的调用父类构造器，虚拟机保证在子类 <clinit>() 方法执行前，父类的 <clinit>() 方法已经执行完毕。
    > 父类中定义的静态语句块要优先于子类先执行。  

    3. <clinit>() 对类和接口来说不是必须的，如果类中没有静态语句块，也没有对变量的赋值操作，则虚拟机可以不生成这个方法。    
    4. 执行接口的 <clinit>() 方法不需要先执行父接口的  <clinit>() 方法，只有当父接口中定义的变量被使用时，父接口才会初始化，接口的实现类在初始化时也不会执行接口的 <clinit>() 方法。    
    5. 虚拟机保证一个类的 <clinit>() 方法在多线程环境中被正确的假设、同步。（同一个类加载器下一个类的只会初始化一次，即 <clinit>() 方法只会执行一次）



## <a name="C">类加载器</a>

### <a name="c1">类与类加载器</a>
* 对应任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性。
### <a name="c2">双亲委派模型</a>
* 从 Java 虚拟机的角度讲只存在两种类加载器
    1. 启动类加载器：C++实现，虚拟机自身一部分。
    2. 其他类加载器：Java实现，独立虚拟机外，并且全部继承自抽象类 java.lang.ClassLoad。
* 从 Java 开发者的角度可以细分为3种类加载器
    1. 启动类加载器：负责把 <JAVA_HOME>/lib 目录中的(或 -Xbootclasspath 指定路径)并且是虚拟机识别的(仅按文件名识别)的类库加载到虚拟机内存中。
    > Java 程序无法直接引用启动类加载器。自定义类加载器需要把加载请求委派给启动类加载器，直接使用 null 代替。    
    2. 扩展类加载器：负责把 <JAVA_HOME>/lib/ext 目录中的(或 java.ext.dirs 系统变量指定路径)的所有类库加载都虚拟机内存。Java 程序可以直接引用。
    3. 应用程序类加载器：ClassLoad.getSystemClassLoader()的返回值。负责加载用户路径(ClassPath)上指定的类库，Java程序可以直接引用。如果应用程序没有自定义过类加载器，一般情况下这个就是程序中默认的类加载器。
* 类加载器的层次：双亲委派模型。
>   自定义类加载器 -> 应用程序类加载器 -> 扩展类加载器 -> 启动类加载器     
>   双亲委派模型要求除了启动类加载器，其他类加载器都应有自己的父类加载器。    
>   这里类加载器的父子关系，一般不使用继承关系实现，而是使用组合关系来复用父加载器的代码。(实际情况Java使用的是继承+组合实现)    
* 双亲委派模型的工作过程：
    1. 一个类加载器收到加载请求，首先把请求委派给自己的父类加载器处理。
    2. 只有父类加载器反馈无法完成这个加载请求(搜索范围没有找到所需的类)时，子类加载器才会尝试自己加载。
>   使用双亲委派模型，保证同一个类在程序的不同类加载器中都是同一个类。    
>   如果没有使用双亲委派模型，假设用户编写了一个 java.lang.Object 的类 ，并放在 ClassPath 中，    
>   那么系统将会出现多个不同的 Object 类；Java 类型体系中最基础的行为也无法保证。
* 双亲委派的代码都封装在 java.lang.ClassLoader 的 loadClass() 中：
    1. 先检查是否已经加载过。
    2. 没有加载过，则调用父类的 loadClass() 方法加载。
    3. 如果父加载器为空(无父加载器)，则使用启动类加载器加载。
    4. 如果 2 3 步加载失败，抛出异常 ClassNotFoundException，然后调用自己的 findClass()方法加载。
    ```java
        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                Class<?> c = findLoadedClass(name);
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        if (parent != null) {
                            c = parent.loadClass(name, false);
                        } else {
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                    }

                    if (c == null) {
                        // If still not found, then invoke findClass in order
                        // to find the class.
                        long t1 = System.nanoTime();
                        c = findClass(name);

                        // this is the defining class loader; record the stats
                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                        sun.misc.PerfCounter.getFindClasses().increment();
                    }
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }
    ```
### <a name="c3">破坏双亲委派模型</a>
