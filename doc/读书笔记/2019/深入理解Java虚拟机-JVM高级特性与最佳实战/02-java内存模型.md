# Java内存模型
######

# 目录索引
  * <a href="#A">Java运行时数据区</a>
    * <a href="#a1">程序计数器</a>
    * <a href="#a2">Java虚拟机栈</a>
    * <a href="#a3">本地方法栈</a>
    * <a href="#a4">堆</a>
    * <a href="#a5">方法区</a>
    * <a href="#a6">运行时常量池</a>
    * <a href="#a7">直接内存</a>
  * <a href="#B">对象的创建</a>
     * <a href="#b1">对象的创建</a>
     * <a href="#b2">对象的内存布局</a>
     * <a href="#b3">对象的访问定位</a>

## <a name="A">Java运行时数据区</a>

![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpeg)

### <a name="a1">程序计数器</a>

* 程序计数器：较小的内存空间，可以看做当前线程执行字节码的行号指示器。字节码解析器工作时通过改变程序计数器的值来选择下一个需要执行的字节码指令。
    * 程序计数器是线程私有的原因：系统通过时间片来轮流切换线程执行，任何时刻一个处理器(多核处理器则为一个内核)只会执行一个线程的指令。为了线程切换后能恢复到正确的执行位置，每个线程必须有一个独立的程序计数器。
    * 程序计数器是唯一一个Java虚拟机规范没有定义任何OOM的区域。

### <a name="a2">Java虚拟机栈</a>

* Java 虚拟机栈：线程私有，随线程生随线程死。每个方法在执行时都会创建一个栈帧。
    * 存储 局部变量表、操作数栈、动态链接、方法出口等信息。
        * 局部变量表：存方法参数、方法声明的局部变量；编译期可知的 基本类型、对象引用、returnAddress类型(指向一条字节指令的地址)。long 和 double 使用两个局部变量空间(solt)，其他的使用一个。所需要的内存空间正在编译期完成分配。
        * 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
    * 方法调用入栈、方法退出出栈。
    * 会出现两种异常 StackOverflowError 和 OutOfMemoryError
        * StackOverflowError：线程请求的栈深度大于虚拟机允许的最大栈深度时抛出。
        * OutOfMemoryError：如果虚拟机允许动态扩展，扩展时无法申请到足够的内存时抛出。

### <a name="a3">本地方法栈</a>
* 本地方法栈：与 Java 虚拟机栈功能类似，只不过为虚拟机使用到的本地方法服务。（sun hotspot 将二者合为一个）。

### <a name="a4">堆</a>
* Java 堆：虚拟机管理最大的一块内存。Java 虚拟机规范：所有的对象实例和数组都要在堆上分配，但是随着 JIT 编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生。
    * 堆细分为 新生代、老年代；新生代有分为 Eden区、 From Servivor To Servivor 区。进一步划分可以更好的回收内存和分配内存。
    * 线程共享。

![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/JVM%E5%A0%86%E9%80%BB%E8%BE%91%E5%88%92%E5%88%86.jpeg)

### <a name="a5">方法区</a>
* 方法区：存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。    
    > 方法区和永久代本质上不等价。仅仅因为 HotSpot 虚拟机把GC分代收集扩展至方法区(或者说使用永久代来实现方法区)，这样做的好处是HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存(方法区)，能够省去专门为方法区编写内存管理代码的工作。    
    > 如何实现方法区是虚拟机实现的细节，不受虚拟机规范约束。但是使用永久代来实现方法区，目前看来不是一个好主意：更容易遇到内存溢出问题(永久代有 -XX:MaxPermSize 上限)，而且存在极少数方法(如string.intern())会因为这个原因导致不同虚拟机下有不同的表现。(jdk1.7 的 HotSpot虚拟机已经把原本放在永久代的字符串常量池移出)    

    * 运行时常量池：存放编译期生成的各种字面量和符号引用。

## < name="B">对象的创建</a>
### <a name="b1">对象的创建</a>
* 对象的创建
    1. 虚拟机遇到 new 指令，检查指令的参数是否能够在常量池中定位到一个“类的符号引用”。
    2. 如果这个符号引用代表的类没有被加载、解析、初始化过，则进行“类的加载过程”。
    3. 类加载检查通过后，为新生对象分配内存(对象所需内存大小在类加载完成后便可以完全确定)。   
        > 指针碰撞：是假设Java堆内存绝对规整，用过的内存放一边，空闲的内存放另一边，中间放一个指针作为分界点的指示器，所分配内存就仅仅是吧那个指针向空闲内存那边挪一段与对象大小相等的距离，这个过程就是指针碰撞。   
        > 空闲列表：是假设Java堆内存不规整，用过的内存和空闲内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从可用内存块中找到一个足够大的空间划分给对象实例，并更新列表上的记录，这个过程就是空闲列表。    
        > 使用哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。使用 Serial、ParNew、等带有 Compact 过程的收集器，系统采用指针碰撞分配方式；使用CMS这种基于 Mark-Sweep 算法的收集器，通常采用空闲列表分配方式。    
        > 分配内存的并发问题解决方案：一种是对分配内存空间的动作进行同步处理-实际上虚拟机使用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块的内存-本地内存分配缓冲(TLAB)。哪个内存要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要进行同步。虚拟机是否使用TLAB，可以通过参数 -XX:+/-UseTLAB 来设定。
    4. 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。如果使用TLAB，这一步可以提前到TLAB中完成。
    5. 虚拟机对对象进行必要的设置：对象是哪个类的实例，如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
    6. 虚拟机角度，对象已经创建完成。Java程序角度，对象创建才刚刚开始-执行new指令紧接着执行<init>方法，把对象安装在程序员的意愿进行初始化。

### <a name="b2">对象的内存布局</a>
* 对象的内存布局：对象头、实例数据、对齐填充。 
    ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg)
    ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%90%84%E9%83%A8%E5%88%86%E9%95%BF%E5%BA%A6.jpg)
    ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%90%84%E9%83%A8%E5%88%86%E7%BB%86%E8%8A%82.jpg)

    1. 对象头包含两部分信息
        1. 存储对象自身运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据在32位和64位(未开启压缩指针)分别为32bit和64bit，官方统称为”Mark Word“。
        2. 类型指针：指向它的类元数据的指针，虚拟机通过这个指针确定这个对象属于哪个类的实例。如果对象是一个数组，那么对象头中还必须有一块用于记录数组长度的数据。
    2. 对象实例数据：对象实际数据包括了对象的所有成员变量(包含继承而来的)，其大小由各个成员变量的大小决定。存储顺序会受到虚拟机分配策略参数(FielfdAllocationStyle)和字段在Java源代码中定义的顺序决定。HotSpot虚拟机默认的分配策略为 longs/doubles ints shorts/chars bytes/booleans oops；从分配策略来看，相同宽度的字段总是被分配在一起。在满足这个条件的前提下，在父类中定义的变量会出现在子类之前。    
        > byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）   
    3. 对齐填充：不是必然的、仅仅起到占位符的作用。由于HotSpot虚拟机要求对象起始地址必须是8字节的整数倍，而对象头部分正好是8字节的倍数，所以，当实例数据部分没有对齐时，就需要对齐补充来不全。

* 对象头占用空间大小
    1. 在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;
    2. 在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;
    3. 64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，MarkWord是8字节，对象头为12字节;
    4. 64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，MarkWord是8字节，对象头为12字节;
    5. 如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组MarkWord为4字节（64位未开启指针压缩的为8字节）;
    6. 静态属性不算在对象大小内。
* 指针压缩：64位JVM消耗的内存会比32位的要多大约1.5倍，这是因为对象指针在64位JVM下有更宽的寻址。对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用，这是开发者不愿意看到的。从JDK 1.6 update14开始，64位的JVM正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。

### <a name="b3">对象的访问定位</a>
* 对象的访问定位：Java程序需要通过栈上的 reference 数据来操作堆上的具体对象。   
    1. 句柄：Java 堆划分一块内存作为句柄池，reference 中存储的就是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息。
        > 好处：reference 中存储的是稳定的句柄地址，在对象被移动(GC)时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
    2. 直接访问：reference 中存储的就是对象地址。
        > 好处：速度更快，节省了一次指针地位的时间开销。 Sun HotSpot 使用直接访问。

* String.intern()：是一个 native 方法，如果一个字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表常量池中这个 String 对象；否则，将此 String 对象包含的字符串添加到常量池，并返回此 String 对象的引用。   

    ```java
    public static void testStringIntern(){
        String str1 = new StringBuilder("计算机").append("软件在").toString();
        System.out.println(str1.intern() == str1);

        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
    // jdk1.6及之前的版本：返回2个false；jdk1.7+版本：返回一个true一个false。
    // jdk1.6: intern()方法会把首次遇到的字符串实例复制到永久代中(常量池)，返回的也是永久代(常量池)中这个字符串的实例，而由 StringBuilder 创建的字符串实例在堆上，所以必然是不同的引用，返回false.
    // jdk1.7: intern()方法不会再复制实例到永久代(常量池)，只是在永久代(常量池)记录首次出现的实例引用，因此 intern()返回的引用和由 StringBuilder 创建的字符串实例是同一个。对 str2 比较返回false，是因为"java"在StringBuilder.toString()之前就已经出现过，字符串常量中已经有了它的引用，不符合“首次出现”原则，而“计算机软件”则是首次出现，因此返回true。
    ```

