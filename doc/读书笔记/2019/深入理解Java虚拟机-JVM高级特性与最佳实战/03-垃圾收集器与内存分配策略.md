# 垃圾收集器与内存分配策略
######

# 目录索引
  * <a href="#A">对象生或死判断方法</a>
    * <a href="#a1">引用计数法</a>
    * <a href="#a2">可达性分析法</a>
    * <a href="#a3">Java四种引用</a>
    * <a href="#a4">对象判断死亡过程</a>
    * <a href="#a5">方法区回收</a>
  * <a href="#B">垃圾收集算法</a>
     * <a href="#b1">标记-清除算法</a>
     * <a href="#b2">复制算法</a>
     * <a href="#b3">标记整理算法</a>
  * <a href="#C">HotSpot 虚拟机的垃圾收集算法实现</a>
     * <a href="#c1">枚举根节点</a>
     * <a href="#c2">安全点</a>
     * <a href="#c3">安全区域</a>
  * <a href="#D">垃圾收集器</a>
     * <a href="#d1">Serial 收集器</a>
     * <a href="#d2">ParNew 收集器</a>
     * <a href="#d3">Parallel Scavenge 收集器</a>
     * <a href="#d4">Serial Old 收集器</a>
     * <a href="#d5">Parallel Old 收集器</a>
     * <a href="#d6">CMS 收集器</a>
     * <a href="#d7">G1 收集器</a>
   * <a href="#E">内存分配与回收策略</a>
     * <a href="#e1">对象优先在 Eden 分配</a>
     * <a href="#e2">大对象直接进入老年代</a>
     * <a href="#e3">长期存活的对象将进入老年代</a>
     * <a href="#e4">动态对象年龄判定</a>
     * <a href="#e5">空间分配担保</a>


## <a name="A">对象生或死判断方法</a>
对象生或死判断方法主要有：引用计数法和可达性分析法。
### <a name="a1">引用计数法</a>
  * 对象有一个引用计数器，一旦有其他地方引用对象，计数器加1，引用失效，计数器减1；任何时候引用计数器为0，则对象不可能再被使用。
    * 使用的语言：微软的COM技术，FlashPlayer，Python，Squirrel。
    * 优点：实现简单，判断效率高。
    * 缺点：很难解决对象直接相互循环引用问题。
### <a name="a2">可达性分析</a>
* 通过一系列称为”GC Roots“ 的对象作为起始点，从这下对象向下搜索，搜索走过的路径称为”引用链“。当一个对象到”GC Roots“没有任何一条引用链相连，则认为对象是不可用的。
  * 使用的语言：Java C# Lisp
  * Java 语言中，可以作为”GC Roots“的对象包括以下几种
    1. 虚拟机栈(栈帧中本地变量表)中引用的对象。
    2. 方法区中类静态属性引用的对象。
    3. 方法区中常量引用的对象。
    4. 本地方法栈中 JNI 引用的对象。
### <a name="a3">Java四种引用</a>
  * 强引用：程序代码中普遍存在的，类似 ”Object obj = new Object()“，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
  * 软引用：有用但非必要的对象，系统将要发生 OOM 之前，垃圾收集器会把这些对象进行第二次回收，如果这次回收仍然没有足够内存，才会抛出 OOM 异常。使用 SoftReference 类来实现软引用。
  * 弱引用：非必要的对象，只被弱弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，不管内存是否足够，都会回收掉只被弱引用关联的对象。使用 WeakReference 类来实现弱引用。
  * 虚引用：一个对象是否有虚引用的存在，不影响其生存时间，也无法通过虚引用来取得一个对象的实例。对象设置虚引用的一个目的就是能够在对象被垃圾收集器回收时收到一个系统通知。使用 PhantomReference 对象实现虚引用。

  > 缓存的实现，最好使用软引用或者弱引用。
### <a name="a4">对象判断死亡过程</a>
  * 真正判断一个对象死亡，至少经过两次标记过程：
    1. 在进行可达性分析后，发现对象没有与 GC Roots 相关联的引用链，对象被进行第一次标记并进行一次筛选，筛选的条件时此对象是否有必要执行执行 finalize() 方法。  
      > 当对象没有没有覆盖 finalize() 方法，或者 finalize() 方法已经被调用过，则视为”没必要“。

    2. 如果对象被判断有必要执行 finalize() 方法，那么把这个对象放到 F-QUEUE 队列中，后续有虚拟机自建、低优先级的 Finalizer 线程去执行它(被标记的对象，执行指触发方法的调用，但是不保证等方法执行完)。 finalize() 方法是对象逃离死亡的最后一次机会，稍后 GC 将对 F-QUEUE 队列进行第二次小规模的标记，只要对象在 finalize() 方法中把自己重新和引用链关联上(如把自己赋值给某个类变量或者对象的成员变量)，那么在第二次标记时，该对象将被移除”即将回收“的集合。   
    > 一个对象的 finalize() 方法只会被系统自动调用一次。

### <a name="a5">方法区回收</a>
  * 永久代的垃圾收集主要是：废弃常量、无用的类。通常永久代垃圾收集的”性价比“比较低。
  * 废弃常量的回收：没有任何引用关联常量池中的常量时，当发生GC时并且有必要，该常量就会被回收。回收过程和Java堆中对象的回收类似。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。
  * 无用的类的回收：必须满足3个条件
    1. 该类所有的实例已经被回收。
    2. 加载该类的 ClassLoader 已经被回收。
    3. 该类对应的 java.lang.Class 对象没有在任何对方被引用，无法在任何地方通过反射的访问该类的方法。
    > 是否对类进行回收 虚拟机提供参数 -Xnoclassgc 进行控制。-XX:+TraceClassLoading -XX:+TraceClassUnLoading 分别查看类的装载和卸载信息。

## <a name="B">垃圾收集算法</a>
垃圾收集算法主要有：标记-清除算法，复制算法，标记整理算法。
### <a name="b1">标记-清除算法</a>
### <a name="b2">复制算法</a>
### <a name="b3">标记整理算法</a>

## <a name="C">HotSpot 虚拟机的垃圾收集算法实现</a>
### <a name="c1">枚举根节点</a>
### <a name="c2">安全点</a>
### <a name="c3">安全区域</a>

## <a name="D">垃圾收集器</a>
垃圾收集器主要有：Serial 收集器，ParNew 收集器，Parallel Scavenge 收集器，Serial Old 收集器，Parallel Old 收集器，CMS 收集器， G1 收集器。
### <a name="d1">Serial 收集器</a>
### <a name="d2">ParNew 收集器</a>
### <a name="d3">Parallel Scavenge 收集器</a>
### <a name="d4">Serial Old 收集器</a>
### <a name="d5">Parallel Old 收集器</a>
### <a name="d6">CMS 收集器</a>
### <a name="d7"> G1 收集器</a>

## <a name="E">内存分配与回收策略</a>
### <a name="e1">对象优先在Eden 分配</a>
### <a name="e2">大对象直接进入老年代</a>
### <a name="e3">长期存活的对象将进入老年代</a>
### <a name="e4">动态对象年龄判定</a>
### <a name="e5">空间分配担保</a>
