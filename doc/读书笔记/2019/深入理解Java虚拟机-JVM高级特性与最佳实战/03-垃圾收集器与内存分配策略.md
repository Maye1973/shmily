# 垃圾收集器与内存分配策略
######

# 目录索引
  * <a href="#A">对象生或死判断方法</a>
    * <a href="#a1">引用计数法</a>
    * <a href="#a2">可达性分析法</a>
    * <a href="#a3">Java四种引用</a>
    * <a href="#a4">对象判断死亡过程</a>
    * <a href="#a5">方法区回收</a>
  * <a href="#B">垃圾收集算法</a>
     * <a href="#b1">标记-清除算法</a>
     * <a href="#b2">复制算法</a>
     * <a href="#b3">标记整理算法</a>
  * <a href="#C">HotSpot 虚拟机的垃圾收集算法实现</a>
     * <a href="#c1">枚举根节点</a>
     * <a href="#c2">安全点</a>
     * <a href="#c3">安全区域</a>
  * <a href="#D">垃圾收集器</a>
     * <a href="#d1">Serial 收集器</a>
     * <a href="#d2">ParNew 收集器</a>
     * <a href="#d3">Parallel Scavenge 收集器</a>
     * <a href="#d4">Serial Old 收集器</a>
     * <a href="#d5">Parallel Old 收集器</a>
     * <a href="#d6">CMS 收集器</a>
     * <a href="#d7">G1 收集器</a>
   * <a href="#E">内存分配与回收策略</a>
     * <a href="#e1">对象优先在 Eden 分配</a>
     * <a href="#e2">大对象直接进入老年代</a>
     * <a href="#e3">长期存活的对象将进入老年代</a>
     * <a href="#e4">动态对象年龄判定</a>
     * <a href="#e5">空间分配担保</a>


## <a name="A">对象生或死判断方法</a>
对象生或死判断方法主要有：引用计数法和可达性分析法。
### <a name="a1">引用计数法</a>
  * 对象有一个引用计数器，一旦有其他地方引用对象，计数器加1，引用失效，计数器减1；任何时候引用计数器为0，则对象不可能再被使用。
    * 使用的语言：微软的COM技术，FlashPlayer，Python，Squirrel。
    * 优点：实现简单，判断效率高。
    * 缺点：很难解决对象直接相互循环引用问题。
### <a name="a2">可达性分析</a>
* 通过一系列称为”GC Roots“ 的对象作为起始点，从这下对象向下搜索，搜索走过的路径称为”引用链“。当一个对象到”GC Roots“没有任何一条引用链相连，则认为对象是不可用的。
  * 使用的语言：Java C# Lisp
  * Java 语言中，可以作为”GC Roots“的对象包括以下几种
    1. 虚拟机栈(栈帧中本地变量表)中引用的对象。
    2. 方法区中类静态属性引用的对象。
    3. 方法区中常量引用的对象。
    4. 本地方法栈中 JNI 引用的对象。
### <a name="a3">Java四种引用</a>
  * 强引用：程序代码中普遍存在的，类似 ”Object obj = new Object()“，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
  * 软引用：有用但非必要的对象，系统将要发生 OOM 之前，垃圾收集器会把这些对象进行第二次回收，如果这次回收仍然没有足够内存，才会抛出 OOM 异常。使用 SoftReference 类来实现软引用。
  * 弱引用：非必要的对象，只被弱弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，不管内存是否足够，都会回收掉只被弱引用关联的对象。使用 WeakReference 类来实现弱引用。
  * 虚引用：一个对象是否有虚引用的存在，不影响其生存时间，也无法通过虚引用来取得一个对象的实例。对象设置虚引用的一个目的就是能够在对象被垃圾收集器回收时收到一个系统通知。使用 PhantomReference 对象实现虚引用。

  > 缓存的实现，最好使用软引用或者弱引用。
### <a name="a4">对象判断死亡过程</a>
  * 真正判断一个对象死亡，至少经过两次标记过程：
    1. 在进行可达性分析后，发现对象没有与 GC Roots 相关联的引用链，对象被进行第一次标记并进行一次筛选，筛选的条件时此对象是否有必要执行执行 finalize() 方法。  
      > 当对象没有没有覆盖 finalize() 方法，或者 finalize() 方法已经被调用过，则视为”没必要“。

    2. 如果对象被判断有必要执行 finalize() 方法，那么把这个对象放到 F-QUEUE 队列中，后续有虚拟机自建、低优先级的 Finalizer 线程去执行它(被标记的对象，执行指触发方法的调用，但是不保证等方法执行完)。 finalize() 方法是对象逃离死亡的最后一次机会，稍后 GC 将对 F-QUEUE 队列进行第二次小规模的标记，只要对象在 finalize() 方法中把自己重新和引用链关联上(如把自己赋值给某个类变量或者对象的成员变量)，那么在第二次标记时，该对象将被移除”即将回收“的集合。   
    > 一个对象的 finalize() 方法只会被系统自动调用一次。

### <a name="a5">方法区回收</a>
  * 永久代的垃圾收集主要是：废弃常量、无用的类。通常永久代垃圾收集的”性价比“比较低。
  * 废弃常量的回收：没有任何引用关联常量池中的常量时，当发生GC时并且有必要，该常量就会被回收。回收过程和Java堆中对象的回收类似。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。
  * 无用的类的回收：必须满足3个条件
    1. 该类所有的实例已经被回收。
    2. 加载该类的 ClassLoader 已经被回收。
    3. 该类对应的 java.lang.Class 对象没有在任何对方被引用，无法在任何地方通过反射的访问该类的方法。
    > 是否对类进行回收 虚拟机提供参数 -Xnoclassgc 进行控制。-XX:+TraceClassLoading -XX:+TraceClassUnLoading 分别查看类的装载和卸载信息。

## <a name="B">垃圾收集算法</a>
垃圾收集算法主要有：标记-清除算法，复制算法，标记整理算法。
### <a name="b1">标记-清除算法</a>
  * 算法分为标记和清除两个过程
    1. 标记需要回收的对象。
    2. 统一回收被标记的对象
  * 缺点
    1. 效率不高
    2. 内存碎片
### <a name="b2">复制算法</a>
  * 复制算法把内存按容量划分为大小相等的2块，每次只是有其中一块。当这块内存使用完了，就把存活的对象复制到另一块，再把这块内存一次性回收。
  * 优点：内存分配只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
  * 缺点：内存可用空间减半，对象存活率高的情况效率非常低。
  > 1. 目前商业虚拟机使用该算法回收新生代。实际实现过程中根据新生代的特点(朝生夕死)，把内存分为一块较大的 Eden 和 两块较小的 Survivor，每次使用 Eden 和 其中一块 Survivor；当回收时，把 Eden 和 Survivor 中存活的对象复制到另一块 Survivor中，然后清理 Eden 和 刚刚使用过的 Survivor。   
  > 2. HotSpot 虚拟机默认 Eden 和 Survivor 的比例为 8:1。这样只有10%的内存"被浪费"(备用的 Survivor)。   
  > 3. 内存担保，我们没办法保证每次回收 Eden 和 Survivor 只有不到 10% 的对象存活，当备用的 Survivor 空间不够时，就需要使用其他内存(老年代)进行担保，把对象直接复制到老年代。
### <a name="b3">标记整理算法</a>
  * 标记需要回收的对象，让存活对象向一端移动，然后直接清理掉端边界以外的内存。
  * 该算法一般使用于老年代。
  > 目前的商业虚拟机都是使用分代收集算法：根据对象存活周期不同，把内存划分为几块，然后针对每块选择合适的收集算法。一般新生代使用”复制“算法；老年代使用 “标记-清理”算法 或者 “标记-整理“算法
## <a name="C">HotSpot 虚拟机的垃圾收集算法实现</a>
### <a name="c1">枚举根节点</a>
  * 可以作为 GC Roots 的节点主要在全局性引用(常量、静态属性)和执行上下文(栈帧本地变量表)中，实际这些内存块很大，扫描这这些内存里额引用耗时，另外可达性分析的时间敏感还体现在GC停顿上。
  * 当执行系统停顿时，不用一个不漏的检查完所有的执行上下文个全局引用的位置，虚拟机应该直接知道哪些地方存放着对象的引用。
  * HotSpot 虚拟机使用一组称为 OopMap 的数据结构来达到这个目的。在类加载完成额时候，HotSpot 虚拟机就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程也会在特定的位置记录下栈和寄存器中哪些位置是引用。
### <a name="c2">安全点</a>
  * OopMap 内容变化的指令很多，如果为每个指令都生成对应的 OopMap 将会花费更大的内存。
  * 实际 HotSpot 虚拟机只是在”特定的位置“记录这些信息，这些位置称为安全点：即程序执行是并非在所有的地方都能停下来进行GC，只有到达安全点时才能停下来进行GC。
  * 安全点选定基本上是以程序”是否具有让程序长时间执行的特征“为标准进行选定的。”长时间执行“最明显的特征就是 指令序列复用(方法调用，循环跳转，异常跳转等)
  * 在GC发生时让线程跑到最近的安全点上再停下来的方式
    1. 抢先式中断：首先把线程全部中断，如果发现有中断的线程不在安全点上，就恢复线程，让线程跑到安全点上。
    2. 主动式中断：当GC需要中断线程时，设置一个标志位，各个线程执行时主动去轮询这个标志位，发现标志位为真时就自己中断挂起。轮询标志位的地方和安全点时重合的，另外加上创建对象需要分配内存的地方。
### <a name="c3">安全区域</a>
  * 安全点机制保证程序执行时，在不太长额时间内就会遇到可进入GC的安全点，但是对于那些没有分配CPU执行时间的线程时没用的，这些不执行的线程无法响应JVM的中断请求，JVM也不可能等待这些线程重新被分配CPU执行时间。
  * 针对以上情况就需要安全区域的概念：在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的
  * 当线程执行到安全区域的代码时，首先标记自己今入了安全区域，当这段时间发生GC时，JVM就不用管那些处于安全区域的线程了。在线程要离开安全区域时，首先检查系统是否已经完成了根节点枚举，如果完成了，那线程继续执行，否则就必须等待直到收到可以安全离开安全区域的信号为止。

## <a name="D">垃圾收集器</a>
垃圾收集器主要有：Serial 收集器，ParNew 收集器，Parallel Scavenge 收集器，Serial Old 收集器，Parallel Old 收集器，CMS 收集器， G1 收集器。
### <a name="d1">Serial 收集器</a>
  * 单线程收集器：执行时暂停其他所有线程，直到它完成垃圾收集工作。
  * client 模式下默认的新生代收集器。
  * 简单高效，在单个CPU的环境，因为没有线程上下文的切换开销，可以获得更高效的效果。
### <a name="d2">ParNew 收集器</a>
  * 是 Serial 收集器 的多线程版本，控制参数、收集参数、对象分配规则、回收策略和 Serial 收集器 完全一致。
  * server 模式下新生代首先的收集器。
  * 除了 Serial 收集器，目前只有 ParNew 收集器 可以和 CMS 收集器配合使用。
  * ParNew 收集器 是使用 -XX:+UseConcMarkSweepGC 选项后默认的新生代收集器。
  * 垃圾收集线程默认与CPU数量相等，可以使用参数 -XX:ParallelGCThreads 参数来设置。

  > 平行：只多条垃圾收集线程平行工作，用户线程被挂起。
  > 并发：垃圾收集线程和用户线程同时执行。

### <a name="d3">Parallel Scavenge 收集器</a>
  * 使用复制算法多线程的新生代收集器，目的是达到一个可控制的吞吐量。
  * 吞吐量：运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。
  * 关键参数：
    1. -XX:MaxGCPauseMillis 大于0的参数，JVM尽量保证内存回收时间不超过该值。
      > 并不是该值越小越好，GC停顿时间缩短是牺牲吞吐量和新生代空间来换取的。
    2. -XX:GCTimeRatio 大于0且小于100的整数，及吞吐量。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。
    3. -XX:UseAdaptiveSizePolicy 自适应调节策略，打开后不用再设置新生代的大小 Eden 和 Survivor 区的比例，晋升老年代对象的年龄，JVM 会根据当前系统运行情况收集性能监控信息，动态调整这些参数以达到最合适的停顿时间或最大的吞吐量。
### <a name="d4">Serial Old 收集器</a>
  * 单线程”标记-整理“算法的老年代收集器。
  * 主要给 client 模式下的虚拟机使用。
  * 主要两个用途：
    1. JDK1.5 前和 Parallet Scavenge 新生代收集器搭配使用。
    2. 作为 CMS 收集器的后备方案，在并发收集器发生 Concurrent Mode Failure 时使用。

### <a name="d5">Parallel Old 收集器</a>
  * 是 Parallel Scavenge 收集器的老年代版本，使用多线程的”标记-整理“算法。(JDK1.6才提供)
  * 在注重吞吐量以及CPU资源的场合，可以优先考虑使用 Parallel Scavenge 和 Parallel Old 收集器。
### <a name="d6">CMS 收集器</a>
  * 目标：实现最短回收停顿时间，关注交互体验。
  * 多线程”标记-清除“算法实现的老年代收集器。
  * 垃圾收集的4个步骤
    1. 初始标记
      > 仅仅标记 GC Roots 可以直接关联的对象，速度快。

    2. 并发标记 
      > 进行 GC Roots Tracing 过程

    3. 重新标记
      > 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，一般这个时间长于初始标记时间，短于并发标记时间。

    4. 并发清除
      > 并发清除回收垃圾对象占用的内存。

  * 缺点
    1. 对 CPU 资源非常敏感。CMS 默认启动回收线程数 = (CPU核数 + 3)/4，也就是当 CPU 核数在4个以上时，回收线程数不少于23%的CPU资源，并且随着CPU核数的增加而下降。但是如果CPU核数不足4个时，CMS对系统的影响可能就很大(系统CPU资源本身就紧张，还要分一般给GC回收)。
    2. CMS 无法处理浮动垃圾，可能出现 ”Concurrent Mode Failure“ 失败而导致另一次 Full GC的产生。
      > 1. 由于在并发清除过程中用户线程还在继续运行，会产生新的垃圾，这部分垃圾出现在标记过程之后，CMS无法在当次收集处理它们，只好留到下一次GC才清除。    
      > 2. 也是由于有浮动垃圾的存在，所以CMS需要预留内存空间给用户线程使用。可以设置 -XX:CMSInitiatingOccupancyFraction 的值来告诉JVM 当老年代使用到达这个百分比就触发一次 Full GC。JDK1.5这个值是68，JDK1.6后是92。   
      > 3. 要是CMS运行期间预留的内存不能满足程序的需求，就会出现一次 ”Concurrent Mode Failure“ 失败，这时虚拟机临时启用 Serial Old 收集器重新进行老年代的垃圾收集，这样停顿时间就会变长。

    3. 因为CMS使用的是 ”标记-清除“算法，所以就会存在内存碎片，造成在分配大对象内存时，老年代还有内存，但是没有足够大的连续内存给当前对象使用，不得不提前触发一次 Full GC。为了解决这个问题 CMS 引入了 -XX:UseCMSCompactAtFullCollection 参数用于 CMS收集器在进行 FullGC 时进行内存碎片的合并整理(无法并发进行)，停顿时间会变长。还可以通过参数 -XX:CMSFullGCsBeforeCompact 告诉JVM在执行多少次不压缩的FullGC后来一次带压缩的。

### <a name="d7"> G1 收集器</a>
  * G1收集器是面向服务端应用的垃圾收集器。JDK7u4开始可以商用。
  * G1特点
    1. 并发与并行，充分利用多CPU、多核特性，减少停顿时间。
    2. 分代收集。
    3. 空间完整：G1整体看使用"标记-整理"算法，局部看(两个 Region 之间)使用"复制"算法。
    4. 可预测的停顿，建立可预测的停顿时间模型，可以让开发者指定在一个长度 M 毫秒的时间片段，消耗在垃圾收集上的时间不得超过 N 秒。

## <a name="E">内存分配与回收策略</a>
### <a name="e1">对象优先在Eden 分配</a>
### <a name="e2">大对象直接进入老年代</a>
### <a name="e3">长期存活的对象将进入老年代</a>
### <a name="e4">动态对象年龄判定</a>
### <a name="e5">空间分配担保</a>
