# 垃圾收集器与内存分配策略
######

# 目录索引
  * <a href="#A">对象生或死判断方法</a>
    * <a href="#a1">引用计数法</a>
    * <a href="#a2">可达性分析法</a>
    * <a href="#a3">Java四种引用</a>
    * <a href="#a4">对象判断死亡过程</a>
    * <a href="#a5">方法区回收</a>
  * <a href="#B">垃圾收集算法</a>
     * <a href="#b1">标记-清除算法</a>
     * <a href="#b2">复制算法</a>
     * <a href="#b3">标记整理算法</a>
  * <a href="#C">HotSpot 虚拟机的垃圾收集算法实现</a>
     * <a href="#c1">枚举根节点</a>
     * <a href="#c2">安全点</a>
     * <a href="#c3">安全区域</a>
  * <a href="#D">垃圾收集器</a>
     * <a href="#d1">Serial 收集器</a>
     * <a href="#d2">ParNew 收集器</a>
     * <a href="#d3">Parallel Scavenge 收集器</a>
     * <a href="#d4">Serial Old 收集器</a>
     * <a href="#d5">Parallel Old 收集器</a>
     * <a href="#d6">CMS 收集器</a>
     * <a href="#d7">G1 收集器</a>
   * <a href="#E">内存分配与回收策略</a>
     * <a href="#e1">对象优先在 Eden 分配</a>
     * <a href="#e2">大对象直接进入老年代</a>
     * <a href="#e3">长期存活的对象将进入老年代</a>
     * <a href="#e4">动态对象年龄判定</a>
     * <a href="#e5">空间分配担保</a>


## <a name="A">对象生或死判断方法</a>
对象生或死判断方法主要有：引用计数法和可达性分析法。
### <a name="a1">引用计数法</a>
  * 对象有一个引用计数器，一旦有其他地方引用对象，计数器加1，引用失效，计数器减1；任何时候引用计数器为0，则对象不可能再被使用。
    * 使用的语言：微软的COM技术，FlashPlayer，Python，Squirrel。
    * 优点：实现简单，判断效率高。
    * 缺点：很难解决对象直接相互循环引用问题。
### <a name="a2">可达性分析</a>
* 通过一系列称为”GC Roots“ 的对象作为起始点，从这下对象向下搜索，搜索走过的路径称为”引用链“。当一个对象到”GC Roots“没有任何一条引用链相连，则认为对象是不可用的。
  * 使用的语言：Java C# Lisp
  * Java 语言中，可以作为”GC Roots“的对象包括以下几种
    1. 虚拟机栈(栈帧中本地变量表)中引用的对象。
    2. 方法区中类静态属性引用的对象。
    3. 方法区中常量引用的对象。
    4. 本地方法栈中 JNI 引用的对象。
### <a name="a3">Java四种引用</a>
  * 强引用：程序代码中普遍存在的，类似 ”Object obj = new Object()“，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
  * 软引用：有用但非必要的对象，系统将要发生 OOM 之前，垃圾收集器会把这些对象进行第二次回收，如果这次回收仍然没有足够内存，才会抛出 OOM 异常。使用 SoftReference 类来实现软引用。
  * 弱引用：非必要的对象，只被弱弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，不管内存是否足够，都会回收掉只被弱引用关联的对象。使用 WeakReference 类来实现弱引用。
  * 虚引用：一个对象是否有虚引用的存在，不影响其生存时间，也无法通过虚引用来取得一个对象的实例。对象设置虚引用的一个目的就是能够在对象被垃圾收集器回收时收到一个系统通知。使用 PhantomReference 对象实现虚引用。

  > 缓存的实现，最好使用软引用或者弱引用。
### <a name="a4">对象判断死亡过程</a>
  * 真正判断一个对象死亡，至少经过两次标记过程：
    1. 在进行可达性分析后，发现对象没有与 GC Roots 相关联的引用链，对象被进行第一次标记并进行一次筛选，筛选的条件时此对象是否有必要执行执行 finalize() 方法。  
      > 当对象没有没有覆盖 finalize() 方法，或者 finalize() 方法已经被调用过，则视为”没必要“。

    2. 如果对象被判断有必要执行 finalize() 方法，那么把这个对象放到 F-QUEUE 队列中，后续有虚拟机自建、低优先级的 Finalizer 线程去执行它(被标记的对象，执行指触发方法的调用，但是不保证等方法执行完)。 finalize() 方法是对象逃离死亡的最后一次机会，稍后 GC 将对 F-QUEUE 队列进行第二次小规模的标记，只要对象在 finalize() 方法中把自己重新和引用链关联上(如把自己赋值给某个类变量或者对象的成员变量)，那么在第二次标记时，该对象将被移除”即将回收“的集合。   
    > 一个对象的 finalize() 方法只会被系统自动调用一次。

### <a name="a5">方法区回收</a>
  * 永久代的垃圾收集主要是：废弃常量、无用的类。通常永久代垃圾收集的”性价比“比较低。
  * 废弃常量的回收：没有任何引用关联常量池中的常量时，当发生GC时并且有必要，该常量就会被回收。回收过程和Java堆中对象的回收类似。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。
  * 无用的类的回收：必须满足3个条件
    1. 该类所有的实例已经被回收。
    2. 加载该类的 ClassLoader 已经被回收。
    3. 该类对应的 java.lang.Class 对象没有在任何对方被引用，无法在任何地方通过反射的访问该类的方法。
    > 是否对类进行回收 虚拟机提供参数 -Xnoclassgc 进行控制。-XX:+TraceClassLoading -XX:+TraceClassUnLoading 分别查看类的装载和卸载信息。

## <a name="B">垃圾收集算法</a>
垃圾收集算法主要有：标记-清除算法，复制算法，标记整理算法。
### <a name="b1">标记-清除算法</a>
  * 算法分为标记和清除两个过程
    1. 标记需要回收的对象。
    2. 统一回收被标记的对象
  * 缺点
    1. 效率不高
    2. 内存碎片
### <a name="b2">复制算法</a>
  * 复制算法把内存按容量划分为大小相等的2块，每次只是有其中一块。当这块内存使用完了，就把存活的对象复制到另一块，再把这块内存一次性回收。
  * 优点：内存分配只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
  * 缺点：内存可用空间减半，对象存活率高的情况效率非常低。
  > 1. 目前商业虚拟机使用该算法回收新生代。实际实现过程中根据新生代的特点(朝生夕死)，把内存分为一块较大的 Eden 和 两块较小的 Survivor，每次使用 Eden 和 其中一块 Survivor；当回收时，把 Eden 和 Survivor 中存活的对象复制到另一块 Survivor中，然后清理 Eden 和 刚刚使用过的 Survivor。   
  > 2. HotSpot 虚拟机默认 Eden 和 Survivor 的比例为 8:1。这样只有10%的内存"被浪费"(备用的 Survivor)。   
  > 3. 内存担保，我们没办法保证每次回收 Eden 和 Survivor 只有不到 10% 的对象存活，当备用的 Survivor 空间不够时，就需要使用其他内存(老年代)进行担保，把对象直接复制到老年代。
### <a name="b3">标记整理算法</a>
  * 标记需要回收的对象，让存活对象向一端移动，然后直接清理掉端边界以外的内存。
  * 该算法一般使用于老年代。
  > 目前的商业虚拟机都是使用分代收集算法：根据对象存活周期不同，把内存划分为几块，然后针对每块选择合适的收集算法。一般新生代使用”复制“算法；老年代使用 “标记-清理”算法 或者 “标记-整理“算法
## <a name="C">HotSpot 虚拟机的垃圾收集算法实现</a>
### <a name="c1">枚举根节点</a>
  * 可以作为 GC Roots 的节点主要在全局性引用(常量、静态属性)和执行上下文(栈帧本地变量表)中，实际这些内存块很大，扫描这这些内存里额引用耗时，另外可达性分析的时间敏感还体现在GC停顿上。
  * 当执行系统停顿时，不用一个不漏的检查完所有的执行上下文个全局引用的位置，虚拟机应该直接知道哪些地方存放着对象的引用。
  * HotSpot 虚拟机使用一组称为 OopMap 的数据结构来达到这个目的。在类加载完成额时候，HotSpot 虚拟机就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程也会在特定的位置记录下栈和寄存器中哪些位置是引用。
### <a name="c2">安全点</a>
  * OopMap 内容变化的指令很多，如果为每个指令都生成对应的 OopMap 将会花费更大的内存。
  * 实际 HotSpot 虚拟机只是在”特定的位置“记录这些信息，这些位置称为安全点：即程序执行是并非在所有的地方都能停下来进行GC，只有到达安全点时才能停下来进行GC。
  * 安全点选定基本上是以程序”是否具有让程序长时间执行的特征“为标准进行选定的。”长时间执行“最明显的特征就是 指令序列复用(方法调用，循环跳转，异常跳转等)
  * 在GC发生时让线程跑到最近的安全点上再停下来的方式
    1. 抢先式中断：首先把线程全部中断，如果发现有中断的线程不在安全点上，就恢复线程，让线程跑到安全点上。
    2. 主动式中断：当GC需要中断线程时，设置一个标志位，各个线程执行时主动去轮询这个标志位，发现标志位为真时就自己中断挂起。轮询标志位的地方和安全点时重合的，另外加上创建对象需要分配内存的地方。
### <a name="c3">安全区域</a>
  * 安全点机制保证程序执行时，在不太长额时间内就会遇到可进入GC的安全点，但是对于那些没有分配CPU执行时间的线程时没用的，这些不执行的线程无法响应JVM的中断请求，JVM也不可能等待这些线程重新被分配CPU执行时间。
  * 针对以上情况就需要安全区域的概念：在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的
  * 当线程执行到安全区域的代码时，首先标记自己今入了安全区域，当这段时间发生GC时，JVM就不用管那些处于安全区域的线程了。在线程要离开安全区域时，首先检查系统是否已经完成了根节点枚举，如果完成了，那线程继续执行，否则就必须等待直到收到可以安全离开安全区域的信号为止。

## <a name="D">垃圾收集器</a>
垃圾收集器主要有：Serial 收集器，ParNew 收集器，Parallel Scavenge 收集器，Serial Old 收集器，Parallel Old 收集器，CMS 收集器， G1 收集器。
### <a name="d1">Serial 收集器</a>
  * 单线程收集器：执行时暂停其他所有线程，直到它完成垃圾收集工作。
  * client 模式下默认的新生代收集器。
  * 简单高效，在单个CPU的环境，因为没有线程上下文的切换开销，可以获得更高效的效果。
### <a name="d2">ParNew 收集器</a>
  * 是 Serial 收集器 的多线程版本，控制参数、收集参数、对象分配规则、回收策略和 Serial 收集器 完全一致。
  * server 模式下新生代首先的收集器。
  * 除了 Serial 收集器，目前只有 ParNew 收集器 可以和 CMS 收集器配合使用。
  * ParNew 收集器 是使用 -XX:+UseConcMarkSweepGC 选项后默认的新生代收集器。
  * 垃圾收集线程默认与CPU数量相等，可以使用参数 -XX:ParallelGCThreads 参数来设置。

  > 平行：只多条垃圾收集线程平行工作，用户线程被挂起。
  > 并发：垃圾收集线程和用户线程同时执行。

### <a name="d3">Parallel Scavenge 收集器</a>
  * 使用复制算法多线程的新生代收集器，目的是达到一个可控制的吞吐量。
  * 吞吐量：运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。
  * 关键参数：
    1. -XX:MaxGCPauseMillis 大于0的参数，JVM尽量保证内存回收时间不超过该值。
      > 并不是该值越小越好，GC停顿时间缩短是牺牲吞吐量和新生代空间来换取的。
    2. -XX:GCTimeRatio 大于0且小于100的整数，及吞吐量。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。
    3. -XX:UseAdaptiveSizePolicy 自适应调节策略，打开后不用再设置新生代的大小 Eden 和 Survivor 区的比例，晋升老年代对象的年龄，JVM 会根据当前系统运行情况收集性能监控信息，动态调整这些参数以达到最合适的停顿时间或最大的吞吐量。
### <a name="d4">Serial Old 收集器</a>
  * 单线程”标记-整理“算法的老年代收集器。
  * 主要给 client 模式下的虚拟机使用。
  * 主要两个用途：
    1. JDK1.5 前和 Parallet Scavenge 新生代收集器搭配使用。
    2. 作为 CMS 收集器的后备方案，在并发收集器发生 Concurrent Mode Failure 时使用。

### <a name="d5">Parallel Old 收集器</a>
  * 是 Parallel Scavenge 收集器的老年代版本，使用多线程的”标记-整理“算法。(JDK1.6才提供)
  * 在注重吞吐量以及CPU资源的场合，可以优先考虑使用 Parallel Scavenge 和 Parallel Old 收集器。
### <a name="d6">CMS 收集器</a>
  * 目标：实现最短回收停顿时间，关注交互体验。
  * 多线程”标记-清除“算法实现的老年代收集器。
  * 垃圾收集的4个步骤
    1. 初始标记
      > 仅仅标记 GC Roots 可以直接关联的对象，速度快。

    2. 并发标记 
      > 进行 GC Roots Tracing 过程

    3. 重新标记
      > 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，一般这个时间长于初始标记时间，短于并发标记时间。

    4. 并发清除
      > 并发清除回收垃圾对象占用的内存。

  * 缺点
    1. 对 CPU 资源非常敏感。CMS 默认启动回收线程数 = (CPU核数 + 3)/4，也就是当 CPU 核数在4个以上时，回收线程数不少于23%的CPU资源，并且随着CPU核数的增加而下降。但是如果CPU核数不足4个时，CMS对系统的影响可能就很大(系统CPU资源本身就紧张，还要分一般给GC回收)。
    2. CMS 无法处理浮动垃圾，可能出现 ”Concurrent Mode Failure“ 失败而导致另一次 Full GC的产生。
      > 1. 由于在并发清除过程中用户线程还在继续运行，会产生新的垃圾，这部分垃圾出现在标记过程之后，CMS无法在当次收集处理它们，只好留到下一次GC才清除。    
      > 2. 也是由于有浮动垃圾的存在，所以CMS需要预留内存空间给用户线程使用。可以设置 -XX:CMSInitiatingOccupancyFraction 的值来告诉JVM 当老年代使用到达这个百分比就触发一次 Full GC。JDK1.5这个值是68，JDK1.6后是92。   
      > 3. 要是CMS运行期间预留的内存不能满足程序的需求，就会出现一次 ”Concurrent Mode Failure“ 失败，这时虚拟机临时启用 Serial Old 收集器重新进行老年代的垃圾收集，这样停顿时间就会变长。

    3. 因为CMS使用的是 ”标记-清除“算法，所以就会存在内存碎片，造成在分配大对象内存时，老年代还有内存，但是没有足够大的连续内存给当前对象使用，不得不提前触发一次 Full GC。为了解决这个问题 CMS 引入了 -XX:UseCMSCompactAtFullCollection 参数用于 CMS收集器在进行 FullGC 时进行内存碎片的合并整理(无法并发进行)，停顿时间会变长。还可以通过参数 -XX:CMSFullGCsBeforeCompact 告诉JVM在执行多少次不压缩的FullGC后来一次带压缩的。

### <a name="d7"> G1 收集器</a>
  * G1收集器是面向服务端应用的垃圾收集器。JDK7u4开始可以商用。
  * G1特点
    1. 并发与并行，充分利用多CPU、多核特性，减少停顿时间。
    2. 分代收集。
    3. 空间完整：G1整体看使用"标记-整理"算法，局部看(两个 Region 之间)使用"复制"算法。
    4. 可预测的停顿，建立可预测的停顿时间模型，可以让开发者指定在一个长度 M 毫秒的时间片段，消耗在垃圾收集上的时间不得超过 N 秒。
      > - 之所以可以实现这样的功能，是因为G1可以有计划的避免在整个 Java 堆中进行安全区域的垃圾收集。  
      > - G1跟踪各个 Region 中垃圾堆积的价值大小(回收获得的空间及耗时经验值)，   
      > - 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值大的 Region。   
      > - 这种使用 Region 划分内存空间以及优先级的区域回收方式，保证了G1收集器在有限时间内可以获得尽可能高的收集效果。

  * G1 收集器 Java 堆的布局：将 Java 对划分为多个大小相等的独立区域(Region)，虽然还保留这新生代和老年代的概念，但它们不再是物理隔离的，它们都是一部分 Region 的集合。
    > Region 大小为 2^n M，默认为 2M。

  ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/G1JMM.jpeg)

    > 在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。   
    > 这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。   
    > 为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。   
    > 如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

  * G1运作步骤
    1. 初始标记
      > 仅仅标记 GC Roots 可以直接关联的对象，并修改 TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 创建对象，需停顿线程，但是耗时短。

    2. 并发标记
      > 从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象，耗时长，但是可以和用户程序并发运行。

    3. 最终标记
      > 修正并发标记期间用户程序继续运行导致标记产生变动的那些标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，需要把 Remembered Set Logs 记录合并到 Remembered Set 中，这阶段需要停顿线程，但是可以并行执行。

    4. 筛选回收
      > 对各个 Region 回收价值和成功进行排序，根据银行期望的 GC 停顿时间制定回收计划，然后回收内存。


  * Region 之间的对象引用以及其他收集器新生代和老年代之间的对象引用，虚拟机都是使用 RememberedSet 来避免全堆扫描的。G1 中每个 Region 都有一个与之对应的 RememberedSet，虚拟机发现程序在对 Reference 类型的数据进行读写操作时，会产生一个 write Barrier 暂时中断写请求，检查 Reference 引用的对象是否处于不同的 Region 之间(分代例子中就是检查是否老年代对象引用新生代对象引用)，如果是，则通过 CardTable 把相关引用信息记录到被引用对象所属 Region 的 RememberedSet 中。当进行内存回收时，在GC 根节点的枚举范围中加入 RememberedSet 即可保证不对全堆扫描也不会遗漏。

  * G1 工作的两种模式
    1. Young GC 
      > Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，
      > 如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间
      > 最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

      ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/G1-YoungGC-Before.png)
      ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/G1-YoungGC-After.png)

      > 这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。

      ![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/Card-Table-Remembered-Set.png)

      > 在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。

      > 但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，
      > 有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。
      > 这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？
      > 这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。

      > 需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，
      > 为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。
      > 一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。
      > 卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。
      > 默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，
      > 即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，
      > Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。
    2. 

## <a name="E">内存分配与回收策略</a>
### <a name="e1">对象优先在Eden 分配</a>
### <a name="e2">大对象直接进入老年代</a>
### <a name="e3">长期存活的对象将进入老年代</a>
### <a name="e4">动态对象年龄判定</a>
### <a name="e5">空间分配担保</a>
