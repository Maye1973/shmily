# java基础复习
######

## 环境变量设置
* 1 编辑 ~/.bash_profile 文件内容如下
```text
JAVA_HOME_8=/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home
JAVA_HOME=$JAVA_HOME_8
PATH=$PATH:$GRADLE_HOME/bin:$PROTOC_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt/jar

export PATH
export JAVA_HOME
export CLASSPATH
```

## 基础知识
### 8种基本数据类型

|类型|存储需求|取值范围|
|:---:|:---:|:---:|
| char | 1字节 | ascII码 |
| byte | 1字节 | -128 ~ 127 |
| short | 2字节 | -32 768 ~ 32 767 |
| int | 4字节 | -2 147 483 648 ~ 2 147 483 647 |
| long | 8字节 | -2 147 483 648 ~ 2 147 483 647 |
| float | 4字节 | |
| double | 8字节 | |
| boolean | 1字节 | |

* 代码点-一个编码表中一个字符对应的代码值。Unicode 标准中代码点使用16进制书写，并加上前缀 U+。

* strictfp 标记的方法必须使用严格的浮点计算来产生理想的结果。 
 
> double w = X\*Y/Z 很多Intel处理器计算 X*Y，并将结果存储在80位的寄存器中，再除以Z并将结果截断为64位。这样可以得到一个更加精确的结果，并且可以避免指数溢出。但是，这个结果可能和在64位的机器上计算结果不一致。因此，java虚拟机最初规范规定所有中间计算都必须进行截断。这种行为遭到数值计算团队反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算上要比精确计算慢。为此，java程序设计语言承认最佳性能与理想结果存在冲突，并给予了改进。默认情况下，虚拟机设计者允许将中间计算结果才有扩展的精度。但是对于使用了strictfp 标记的方法必须使用严格的浮点计算来产生理想的结果。

* 位运算 >>> 运算符将用0填充高位，>> 运算符用符号位填充高位。  
> 对移位运算符右侧的参数需要进行模32位的运算（除非右边的操作数是long，这时需要对右侧参数模64）。例如 1<<35 和 1<< 3 ，1<<8是一样的。

### 数值类型转换规则

- 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。
- 否则，如果其中一个操作数是float类型，另一个操作数就会转换为float类型。
- 否则，如果其中一个操作数是long类型，另一个操作数就会转换为long类型。
- 否则，两个操作数都转换为int类型。

![avatar](../img/8种基本类型转换.png)