# Java内存模型
######

# 目录索引
  * <a href="#A">Java运行时数据区</a>
    * <a href="#a1">程序计数器</a>
    * <a href="#a2">Java虚拟机栈</a>
    * <a href="#a3">本地方法栈</a>
    * <a href="#a4">堆</a>
    * <a href="#a5">方法区</a>
    * <a href="#a6">运行时常量池</a>
    * <a href="#a7">直接内存</a>
  * <a href="#B">基础知识</a>
     * <a href="#b1">8种基本数据类型</a>
     * <a href="#b2">数值类型转换规则</a>
     * <a href="#b3">Arrays类</a>

## <a name="A">Java运行时数据区</a>

![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpeg)

### <a name="a1">程序计数器</a>

* 程序计数器：较小的内存空间，可以看做当前线程执行字节码的行号指示器。字节码解析器工作时通过改变程序计数器的值来选择下一个需要执行的字节码指令。
    * 程序计数器是线程私有的原因：系统通过时间片来轮流切换线程执行，任何时刻一个处理器(多核处理器则为一个内核)只会执行一个线程的指令。为了线程切换后能恢复到正确的执行位置，每个线程必须有一个独立的程序计数器。
    * 程序计数器是唯一一个Java虚拟机规范没有定义任何OOM的区域。

* Java 虚拟机栈：线程私有，随线程生随线程死。每个方法在执行时都会创建一个栈帧。
    * 存储 局部变量表、操作数栈、动态链接、方法出口等信息。
        * 局部变量表：存方法参数、方法声明的局部变量；编译期可知的 基本类型、对象引用、returnAddress类型(指向一条字节指令的地址)。long 和 double 使用两个局部变量空间(solt)，其他的使用一个。所需要的内存空间正在编译期完成分配。
        * 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
    * 方法调用入栈、方法退出出栈。
    * 会出现两种异常 StackOverflowError 和 OutOfMemoryError
        * StackOverflowError：线程请求的栈深度大于虚拟机允许的最大栈深度时抛出。
        * OutOfMemoryError：如果虚拟机允许动态扩展，扩展时无法申请到足够的内存时抛出。

* 本地方法栈：与 Java 虚拟机栈功能类似，只不过为虚拟机使用到的本地方法服务。（sun hotspot 将二者合为一个）。

* Java 堆：虚拟机管理最大的一块内存。Java 虚拟机规范：所有的对象实例和数组都要在堆上分配，但是随着 JIT 编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生。
    * 堆细分为 新生代、老年代；新生代有分为 Eden区、 From Servivor To Servivor 区。进一步划分可以更好的回收内存和分配内存。
    * 线程共享。

![image](https://raw.githubusercontent.com/Maye1973/shmily/develop/doc/img/JVM%E5%A0%86%E9%80%BB%E8%BE%91%E5%88%92%E5%88%86.jpeg)

* 方法区：存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。    
    > 方法区和永久代本质上不等价。仅仅因为 HotSpot 虚拟机把GC分代收集扩展至方法区(或者说使用永久代来实现方法区)，这样做的好处是HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存(方法区)，能够省去专门为方法区编写内存管理代码的工作。    
    > 如何实现方法区是虚拟机实现的细节，不受虚拟机规范约束。但是使用永久代来实现方法区，目前看来不是一个好主意：更容易遇到内存溢出问题(永久代有 -XX:MaxPermSize 上限)，而且存在极少数方法(如string.intern())会因为这个原因导致不同虚拟机下有不同的表现。(jdk1.7 的 HotSpot虚拟机已经把原本放在永久代的字符串常量池移出)    

    * 运行时常量池：存放编译期生成的各种字面量和符号引用。

* 对象的创建
    1. 虚拟机遇到 new 指令，检查指令的参数是否能够在常量池中定位到一个“类的符号引用”。
    2. 如果这个符号引用代表的类没有被加载、解析、初始化过，则进行“类的加载过程”。
    3. 类加载检查通过后，为新生对象分配内存(对象所需内存大小在类加载完成后便可以完全确定)。   
        > 指针碰撞：是假设Java堆内存绝对规整，用过的内存放一边，空闲的内存放另一边，中间放一个指针作为分界点的指示器，所分配内存就仅仅是吧那个指针向空闲内存那边挪一段与对象大小相等的距离，这个过程就是指针碰撞。   
        > 空闲列表：是假设Java堆内存不规整，用过的内存和空闲内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从可用内存块中找到一个足够大的空间划分给对象实例，并更新列表上的记录，这个过程就是空闲列表。    
        > 使用哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。使用 Serial、ParNew、等带有 Compact 过程的收集器，系统采用指针碰撞分配方式；使用CMS这种基于 Mark-Sweep 算法的收集器，通常采用空闲列表分配方式。    
        > 分配内存的并发问题解决方案：一种是对分配内存空间的动作进行同步处理-实际上虚拟机使用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块的内存-本地内存分配缓冲(TLAB)。哪个内存要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要进行同步。虚拟机是否使用TLAB，可以通过参数 -XX:+/-UseTLAB 来设定。
    4. 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。如果使用TLAB，这一步可以提前到TLAB中完成。
    5. 虚拟机对对象进行必要的设置：对象是哪个类的实例，如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
    6. 虚拟机角度，对象已经创建完成。Java程序角度，对象创建才刚刚开始-执行new指令紧接着执行<init>方法，把对象安装在程序员的意愿进行初始化。
* 对象的内存分布
